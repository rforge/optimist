library(DEoptim)
install.packages("DEoptim")
library(DEoptim)
### 2 Inputs:#
IV<-data.frame(IV=c(0,6672895.687,13345791.37,20018687.06,26691582.75,33364478.44,40037374.12,46710269.81,53383165.5,60056061.18,66728956.87,73401852.56,80074748.24,86747643.93,93420539.62,100093435.3,106766331,113439226.7,120112122.4,126785018.1,133457913.7,140130809.4,146803705.1,153476600.8,160149496.5,166822392.2,173495287.9,180168183.5,186841079.2,193513974.9,200186870.6))#
DV<-data.frame(DV=c(0,439.8839775,829.7360945,1176.968757,1487.732038,1767.147276,2019.49499,2248.366401,2456.78592,2647.310413,2822.109854,2983.033036,3131.661246,3269.352233,3397.276321,3516.446162,3627.741311,3731.928591,3829.679009,3921.581866,4008.156537,4089.862363,4167.106955,4240.253215,4309.625263,4375.513474,4438.178766,4497.856259,4554.75841,4609.077705,4660.988983))#
#
## Function "transformIV" transforms a data frame column "IV" using#
parameters .alpha & .beta:#
## It returns a data frame column IV_transf:#
transformIV = function(.alpha,.beta) {#
 IV_transf <- as.data.frame(1 - (1/exp((IV/.beta)^.alpha)))#
 return(IV_transf)#
}#
#
### Function "mysum" calculates the sum of absolute residuals after a#
regression with a single predictor:#
mysum<- function(myIV,myDV){#
  regr<-lm(myDV[[1]] ~ 0 + myIV[[1]])#
  mysum<-sum(abs(regr$resid))#
  return(mysum)#
}#
#
### Function to be optimized;#
### param is a vector of 2 values (.alpha and .beta)#
myfunc <- function(param){#
  myalpha<-param[1]#
  mybeta<-param[2]#
  IVtransf<-transformIV(myalpha, mybeta)#
  sumofdevs<-mysum(myIV=IVtransf,myDV=DV)#
  return(sumofdevs)#
}
## 2 Inputs:#
IV<-data.frame(IV=c(0,6672895.687,13345791.37,20018687.06,26691582.75,33364478.44,40037374.12,46710269.81,53383165.5,60056061.18,66728956.87,73401852.56,80074748.24,86747643.93,93420539.62,100093435.3,106766331,113439226.7,120112122.4,126785018.1,133457913.7,140130809.4,146803705.1,153476600.8,160149496.5,166822392.2,173495287.9,180168183.5,186841079.2,193513974.9,200186870.6))#
DV<-data.frame(DV=c(0,439.8839775,829.7360945,1176.968757,1487.732038,1767.147276,2019.49499,2248.366401,2456.78592,2647.310413,2822.109854,2983.033036,3131.661246,3269.352233,3397.276321,3516.446162,3627.741311,3731.928591,3829.679009,3921.581866,4008.156537,4089.862363,4167.106955,4240.253215,4309.625263,4375.513474,4438.178766,4497.856259,4554.75841,4609.077705,4660.988983))#
#
## Function "transformIV" transforms a data frame column "IV" using#
## parameters .alpha & .beta:#
## It returns a data frame column IV_transf:#
transformIV = function(.alpha,.beta) {#
 IV_transf <- as.data.frame(1 - (1/exp((IV/.beta)^.alpha)))#
 return(IV_transf)#
}#
#
## Function "mysum" calculates the sum of absolute residuals after a#
## regression with a single predictor:#
mysum<- function(myIV,myDV){#
  regr<-lm(myDV[[1]] ~ 0 + myIV[[1]])#
  mysum<-sum(abs(regr$resid))#
  return(mysum)#
}#
#
## Function to be optimized;#
## param is a vector of 2 values (.alpha and .beta)#
myfunc <- function(param){#
  myalpha<-param[1]#
  mybeta<-param[2]#
  IVtransf<-transformIV(myalpha, mybeta)#
  sumofdevs<-mysum(myIV=IVtransf,myDV=DV)#
  return(sumofdevs)#
}
myopt <- optim(fn=myfunc, par=c(0.1,max(IV)), method="L-BFGS-B", lower=0)
myopt
myfunc(c(0.888452533990788,94812732.0897449))
(myopt)
newfunction <- function(xy) myfunc(c(xy[1],1e9*xy[2]))
optim(newfunction, par=c(0.5, 0.5), lower=c(0,0), upper=c(1,1))
?DEoptim
DEoptim(newfunction, lower=c(0,0), upper=c(1,1))
myfunc(c(0.888452533990788,94812732.0897449))
myfunc(c(0.8897642, 94701140))
options(digits=15)
DEoptim(newfunction, lower=c(0,0), upper=c(1,1))
myfunc(c(0.889764228, 94701144.6))
setwd('/Users/HwB/Work/myRforge/optimist/pkg/gloptim/R')
simpleEA <-#
function(fun, lower, upper, N=100, #
                     eps=1e-6, scl=1/2, log=TRUE)#
{#
    # if ( length(lower) != length(upper) ) error()#
    # if ( !scale < 1 ) error#
#
    n <- length(lower)#
    z <- (upper + lower)/2      # midpoint of rectangle#
    h0 <- upper - lower         # side lengths of rectangle#
#
    P <- 1                      # no. of parents#
    Parents <- matrix(z, nrow=P)#
    fvals   <- fun(z)#
#
    h <- scl * h0#
    while ( min(h) > eps ) {#
        newParents <- rbind(    # TODO: keep new parents in rectangle !#
            Parents,#
            kronecker(Parents, rep(1, N)) + #
                matrix(runif(P*N*n, -1, 1), ncol=n) %*% diag(h) )#
        newFvals <- apply(newParents, 1, fun)#
        orderParents <- order(newFvals)#
        Parents <- newParents[orderParents[1:N],]#
        fvals <- apply(Parents, 1, fun)#
#
        if (log) cat(min(fvals), "\n")#
#
        # initialize new loop#
        P <- N                  # TODO: avoid this#
        h <- scl * h#
    }#
#
    return( list(par=Parents[1,], val=min(fvals), scl=max(h)) )#
}
simpleEA(newfunction, lower=c(0,0), upper=c(1,1))
?optim
optim(Par = c(0.889764228112319 0.0947011445712312), newfunction)
optim(Par = c(0.889764228112319, 0.0947011445712312), newfunction)
optim(par = c(0.889764228112319, 0.0947011445712312), newfunction)
p1 <- c(0.8897642281123190, 0.0947011445712312)
p2 <- c(0.888452533990788,  0.0948127320897449)
fun <- function(t) newfunction((p1 + t*(p2-p1)))
ezplot(fun, 0, 1)
library(pracma)
ezplot(fun, 0, 1)
p2
p1
p2 - p1
p1 + 0.5*(p2-p1)
y <- numeric(101)
x <- seq(0, 1, len=101)
length(y)
for (i in 1:101) y[i] <- fun(x[i])
plot(x, y)
x <- seq(-1, 1, len=101)
for (i in 1:101) y[i] <- fun(x[i])
plot(x, y)
myfunc(c(0.888452533990788, 94812732.0897449))
myfunc(c(0.889764228112319, 94701144.5712312))
optim(par = c(0.888452533990788, 94812732.0897449), newfunction)
optim(par = c(0.888452533990788, 0.0948127320897449), newfunction)

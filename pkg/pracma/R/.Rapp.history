library(sos)
findFn("cond")
library(pracma)
cond <- function(M, p == 1) {#
    if (!is.numeric(M))#
        stop("Argument 'M' must be a numeric matrix.")#
    if (is.vector(M))#
        M <- matrix(c(M), nrow = length(M), ncol = 1)#
#
    if (length(M) == 0) return(c())#
    if (ncol(M) != nrow(M) && p != 2)#
        stop("Matrix 'M' must be square if p = 2.")#
#
    if (p == 2) {#
        s <- svd(M)$d#
        cnd <- if (any(s) == 0) Inf else max(s) / min(s)#
    } else {#
        cnd <- norm(M, p) * norm(inv(M), p)#
    }#
    return(cnd)#
}
cond <- function(M, p = 1) {#
    if (!is.numeric(M))#
        stop("Argument 'M' must be a numeric matrix.")#
    if (is.vector(M))#
        M <- matrix(c(M), nrow = length(M), ncol = 1)#
#
    if (length(M) == 0) return(c())#
    if (ncol(M) != nrow(M) && p != 2)#
        stop("Matrix 'M' must be square if p = 2.")#
#
    if (p == 2) {#
        s <- svd(M)$d#
        cnd <- if (any(s) == 0) Inf else max(s) / min(s)#
    } else {#
        cnd <- norm(M, p) * norm(inv(M), p)#
    }#
    return(cnd)#
}
cond(hilb(8))
cond(hilb(8), 2)
cond <- function(M, p = 1) {#
    if (!is.numeric(M))#
        stop("Argument 'M' must be a numeric matrix.")#
    if (is.vector(M))#
        M <- matrix(c(M), nrow = length(M), ncol = 1)#
#
    if (length(M) == 0) return(c())#
    if (ncol(M) != nrow(M) && p != 2)#
        stop("Matrix 'M' must be square if p = 2.")#
#
    if (p == 2) {#
        s <- svd(M)$d#
        cnd <- if (any(s == 0)) Inf else max(s) / min(s)#
    } else {#
        cnd <- norm(M, p) * norm(inv(M), p)#
    }#
    return(cnd)#
}
cond(hilb(8), 2)
cond(hilb(4), 2)
cond(magic(4), 2)
svd(magic(4))
normest <- function(M, maxiter = 100, tol = .Machine$double.eps^(1/2)) {#
    if (!is.numeric(M))#
        stop("Argument 'M' must be a numeric matrix.")#
    if (is.vector(M))#
        M <- matrix(c(M), nrow = length(M), ncol = 1)#
#
    x <- matrix(apply(abs(M), 2, sum), ncol = 1)#
    est <- norm(x, "F")      # Frobenius Norm#
    if (est == 0) return(0)#
#
    x <- x/est#
    est0 <- 0#
    niter <- 0#
    while (abs(est - est0) > tol * est && niter <= maxiter) {#
        est0 <- est#
        Mx <- M %*% x#
        if (all(Mx == 0))#
            Mx <- matrix(runif(length(Mx)), ncol(Mx), nrow(Mx))#
        x <- t(M) %*% Mx#
        normx <- norm(x, "F")#
        est <- normx / norm(Mx, "F")#
        x <- x / normx#
        niter <- niter + 1#
    }#
    if (niter > maxiter)#
        warning("Number of iterations exceeded 'maxiter'.")#
#
    return(est)#
}
normest(magic(4))
svd(magic(4))$d
normest(magic(100))
mrank <- function(M) {#
    if (!is.numeric(M))#
        stop("Argument 'M' must be a numeric matrix.")#
    if (is.vector(M))#
        M <- matrix(c(M), nrow = length(M), ncol = 1)#
#
    # The MASS way#
    r1 <- qr(M)$rank#
#
    # The Matlab way#
    sigma <- svd(M)$d#
    tol <- max(dim(M)) * max(sigma) * .Machine$double.eps#
    r2 <- sum(sigma > tol)#
#
    if (r1 != r2)#
        warning("Rank calculation may be problematic.")#
    return(r2)#
}#
#
#
kernel <- function(M) {#
    if (!is.numeric(M))#
        stop("Argument 'M' must be a numeric matrix.")#
    if (is.vector(M))#
        M <- matrix(c(M), nrow = length(M), ncol = 1)#
#
    qrM <- qr(M)#
    rank <- qrM$rank#
    inds <- if (rank == 0) 1:ncol(M) else -(1:rank)#
#
    qrQ <- qr.Q(qrM, complete = TRUE)[, inds, drop = FALSE]#
    return(t(qrQ))#
}
M <- matrix(1:12, 3, 4)
M
kernel(M)
mrank(M)
N <- kernel(M)
N %*% M
M <- matrix(1:12, 4, 3)
rank(M)
mrank(M)
M <- magic(4)
rank(M)
mrank(M)
M <- magic(5)
mrank(M)
kernel(M)
length(kernel(M))
M <- magic(5)
qrM <- qr(M)
qrM
inds <- if (rank == 0) 1:ncol(M) else -(1:rank)
qrM$rank
setwd('/Users/HwB/Work/myRforge/optimist/pkg/pracma/R')
kernel <- function(M) {#
    if (!is.numeric(M))#
        stop("Argument 'M' must be a numeric matrix.")#
    if (is.vector(M))#
        M <- matrix(c(M), nrow = length(M), ncol = 1)#
#
    qrM <- qr(M)#
    rank <- qrM$rank#
    if (rank == ncol(M)) return(rep(0, ncol(M)))#
#
    inds <- if (rank == 0) 1:ncol(M) else -(1:rank)#
    qrQ <- qr.Q(qrM, complete = TRUE)[, inds, drop = FALSE]#
#
    if (length(qrQ) == 0)#
        return(rep(0, ))#
    return(t(qrQ))#
}
M
kernel(M)
a <- c(1,2); b <- c(2, 1)
orth(A)
orth <- function(M) {#
    if (!is.numeric(M))#
        stop("Argument 'M' must be a numeric matrix.")#
    if (is.vector(M))#
        M <- matrix(c(M), nrow = length(M), ncol = 1)#
#
    svdM <- svd(M)#
    U <- svdM$u#
    s <- svdM$d#
    tol <-  max(dim(M)) * max(s) * .Machine$double.eps#
#
    r <- sum(s > tol)#
    Q <- U[,1:r, drop = FALSE]#
}
orth(A)
orth(a)
setwd('/Users/HwB/Work/myRforge/optimist/pkg/pracma/R')
orth <- function(M) {#
    if (!is.numeric(M))#
        stop("Argument 'M' must be a numeric matrix.")#
    if (is.vector(M))#
        M <- matrix(c(M), nrow = length(M), ncol = 1)#
#
    svdM <- svd(M)#
    U <- svdM$u#
    s <- svdM$d#
    tol <-  max(dim(M)) * max(s) * .Machine$double.eps#
#
    r <- sum(s > tol)#
    U[,1:r, drop = FALSE]#
}
orth(a)
orth(c(1,2))
orth(t(t(c(1,2))))
180 * subspace(c(1, 2), c(2, 1)) / pi#
180 * subspace(c(0, 1), c(1, 2)) / pi
subspace <- function(A, B) {#
    if (!is.numeric(A) || !is.numeric(B))#
        stop("Arguments 'A' and 'B' must be numeric matrices.")#
#
    A <- orth(A)#
    B <- orth(B)#
    if (ncol(A) < ncol(B)) {#
        tmp <- A; A <- B; B <- tmp#
    }#
#
    for (k in 1:ncol(A)) {#
        B <- B - A[, k] %*% t(A[, k]) %*% B#
    }#
#
    asin(min(1, svd(B)$d))#
}
180 * subspace(c(1, 2), c(2, 1)) / pi#
180 * subspace(c(0, 1), c(1, 2)) / pi
a <- matrix(c(1:8), 4, 2); b <- matrix(c(6:1), 3, 2)
a
b
subspace(a, b)
subspace <- function(A, B) {#
    if (!is.numeric(A) || !is.numeric(B))#
        stop("Arguments 'A' and 'B' must be numeric matrices.")#
    if (is.vector(A))#
        A <- matrix(c(A), nrow = length(A), ncol = 1)#
    if (is.vector(B))#
        B <- matrix(c(B), nrow = length(), ncol = 1)#
    if (nrow(A) != nrow(B))#
        stop("Matrices 'A' and 'B' must have the same number of rows.")#
#
    A <- orth(A)#
    B <- orth(B)#
    if (ncol(A) < ncol(B)) {#
        tmp <- A; A <- B; B <- tmp#
    }#
#
    for (k in 1:ncol(A)) {#
        B <- B - A[, k] %*% t(A[, k]) %*% B#
    }#
#
    asin(min(1, svd(B)$d))#
}
subspace(a, b)
M <- magic(10)
M
orth(M)
M <- matrix(1:12, 3, 4)#
mrank(M)                 #=> 2#
orth(M)

cbind(2,3)
y <- matrix(c(1,2,3,4), 2, 2)
y
y[1,]
y <- c(5, 7, 10, 15, 18, 20)
dist(y)
diff(y)
setwd('/Users/HwB/Work/myRforge/optimist/pkg/pracma/R')
findpeaks <- function(x,nups = 1, ndowns = nups, zero = "0", peakpat = NULL, #
                      # peakpat = "[+]{2,}[0]*[-]{2,}", #
                      minpeakheight = -Inf, minpeakdistance = 1,#
                      threshold = 0, npeaks = 0, sortstr = FALSE)#
{#
    stopifnot(is.vector(x, mode="numeric"))#
    if (! zero %in% c('0', '+', '-'))#
        stop("Argument 'zero' can only be '0', '+', or '-'.")#
#
    # transform x into a "+-+...-+-" character string#
    xc <- paste(as.character(sign(diff(x))), collapse="")#
    xc <- gsub("1", "+", gsub("-1", "-", xc))#
    # transform '0' to zero#
    if (zero != '0') xc <- gsub("0", zero, xc)#
#
    # generate the peak pattern with no of ups and downs#
    if (is.null(peakpat)) {#
        peakpat <- sprintf("[+]{%d,}[-]{%d,}", nups, ndowns)#
    }#
#
    # generate and apply the peak pattern#
    rc <- gregexpr(peakpat, xc)[[1]]#
    if (rc[1] < 0) return(NULL)#
#
    # get indices from regular expression parser#
    x1 <- rc#
    x2 <- rc + attr(rc, "match.length") - 1#
    attributes(x1) <- NULL#
    attributes(x2) <- NULL#
#
    # find index positions and maximum values#
    n <- length(x1)#
    xv <- xp <- numeric(n)#
    for (i in 1:n) {#
        xp[i] <- which.max(x[x1[i]:x2[i]]) + x1[i] - 1#
        xv[i] <- x[xp[i]]#
    }#
#
    # eliminate peaks that are too low#
    inds <- which(xv >= minpeakheight & xv - pmax(x[x1], x[x2]) >= threshold)#
#
    # combine into a matrix format#
    X <- cbind(xv[inds], xp[inds], x1[inds], x2[inds])#
#
    # eliminate peaks that are near by#
    if (minpeakdistance != 1)#
        warning("Handling 'minpeakdistance' has not yet been implemented.")#
#
    # Sort according to peak height#
    if (sortstr) {#
        sl <- sort.list(X[, 1], na.last = NA, decreasing = TRUE)#
        X <- X[sl, ]#
    }#
#
    # Return only the first 'npeaks' peaks#
    if (npeaks > 0 && npeaks < nrow(X)) {#
        X <- X[1:npeaks, ]#
    }#
#
    if (length(X) == 0)    return(c())#
    else if (nrow(X) == 1) return(drop(X))#
    else return(X)#
}
x <- c(2, 12, 4, 6, 9, 4, 3, 1, 19, 7)
identical(findpeaks(x, npeaks = 1, sortstr = TRUE),
c(19, 9, 8, 9))
options(error=recover)
identical(findpeaks(x, npeaks = 1, sortstr = TRUE),
options(error=recover)
identical(findpeaks(x, npeaks = 1, sortstr = TRUE),
c(19, 9, 8, 9))
x
X
n
y <- matrix(0 + 1:12, 3, 4)
y
y[1, ]
y[1, , drop=FALSE]
y[1, , drop=FALSE]
findpeaks <- function(x,nups = 1, ndowns = nups, zero = "0", peakpat = NULL, #
                      # peakpat = "[+]{2,}[0]*[-]{2,}", #
                      minpeakheight = -Inf, minpeakdistance = 1,#
                      threshold = 0, npeaks = 0, sortstr = FALSE)#
{#
    stopifnot(is.vector(x, mode="numeric"))#
    if (! zero %in% c('0', '+', '-'))#
        stop("Argument 'zero' can only be '0', '+', or '-'.")#
#
    # transform x into a "+-+...-+-" character string#
    xc <- paste(as.character(sign(diff(x))), collapse="")#
    xc <- gsub("1", "+", gsub("-1", "-", xc))#
    # transform '0' to zero#
    if (zero != '0') xc <- gsub("0", zero, xc)#
#
    # generate the peak pattern with no of ups and downs#
    if (is.null(peakpat)) {#
        peakpat <- sprintf("[+]{%d,}[-]{%d,}", nups, ndowns)#
    }#
#
    # generate and apply the peak pattern#
    rc <- gregexpr(peakpat, xc)[[1]]#
    if (rc[1] < 0) return(NULL)#
#
    # get indices from regular expression parser#
    x1 <- rc#
    x2 <- rc + attr(rc, "match.length") - 1#
    attributes(x1) <- NULL#
    attributes(x2) <- NULL#
#
    # find index positions and maximum values#
    n <- length(x1)#
    xv <- xp <- numeric(n)#
    for (i in 1:n) {#
        xp[i] <- which.max(x[x1[i]:x2[i]]) + x1[i] - 1#
        xv[i] <- x[xp[i]]#
    }#
#
    # eliminate peaks that are too low#
    inds <- which(xv >= minpeakheight & xv - pmax(x[x1], x[x2]) >= threshold)#
#
    # combine into a matrix format#
    X <- cbind(xv[inds], xp[inds], x1[inds], x2[inds])#
#
    # eliminate peaks that are near by#
    if (minpeakdistance != 1)#
        warning("Handling 'minpeakdistance' has not yet been implemented.")#
#
    # Sort according to peak height#
    if (sortstr) {#
        sl <- sort.list(X[, 1], na.last = NA, decreasing = TRUE)#
        X <- X[sl, , drop = FALSE]#
    }#
#
    # Return only the first 'npeaks' peaks#
    if (npeaks > 0 && npeaks < nrow(X)) {#
        X <- X[1:npeaks, , drop = FALSE]#
    }#
#
    if (length(X) == 0)    return(c())#
    # else if (nrow(X) == 1) return(drop(X))#
    else return(X)#
}
x <- c(2, 12, 4, 6, 9, 4, 3, 1, 19, 7)#
identical(findpeaks(x),#
          matrix(c(12,9,19, 2,5,9, 1,3,8, 2,7,9), nrow=3, ncol=4))#
identical(findpeaks(x, npeaks = 1, sortstr = TRUE),#
          c(19, 9, 8, 9))#
identical(findpeaks(x, minpeakheight = 15),#
          c(19, 9, 8, 9))
findpeaks(x, threshold = 10)
x
nups <- ndowns <- 1
zero <- '0'
peakpat <- NULL
minpeakheight = -Inf; minpeakdistance = 1
threshold = 10; npeaks = 0; sortstr = FALSE
setwd('/Users/HwB/Work/myRforge/optimist/pkg/pracma/R')
    xc <- paste(as.character(sign(diff(x))), collapse="")#
    xc <- gsub("1", "+", gsub("-1", "-", xc))#
    # transform '0' to zero#
    if (zero != '0') xc <- gsub("0", zero, xc)#
#
    # generate the peak pattern with no of ups and downs#
    if (is.null(peakpat)) {#
        peakpat <- sprintf("[+]{%d,}[-]{%d,}", nups, ndowns)#
    }
setwd('/Users/HwB/Work/myRforge/optimist/pkg/pracma/R')
    rc <- gregexpr(peakpat, xc)[[1]]#
    if (rc[1] < 0) return(NULL)#
#
    # get indices from regular expression parser#
    x1 <- rc#
    x2 <- rc + attr(rc, "match.length") - 1#
    attributes(x1) <- NULL#
    attributes(x2) <- NULL
setwd('/Users/HwB/Work/myRforge/optimist/pkg/pracma/R')
    n <- length(x1)#
    xv <- xp <- numeric(n)#
    for (i in 1:n) {#
        xp[i] <- which.max(x[x1[i]:x2[i]]) + x1[i] - 1#
        xv[i] <- x[xp[i]]#
    }
xp
xv
xv - pmax(x[x1], x[x2])
cbind(xv, xp, x1, x2)
pmax(x[x1], x[x2])
x[x1]
x[x2]
x
setwd('/Users/HwB/Work/myRforge/optimist/pkg/pracma/R')
    xc <- paste(as.character(sign(diff(x))), collapse="")#
    xc <- gsub("1", "+", gsub("-1", "-", xc))#
    # transform '0' to zero#
    if (zero != '0') xc <- gsub("0", zero, xc)#
#
    # generate the peak pattern with no of ups and downs#
    if (is.null(peakpat)) {#
        peakpat <- sprintf("[+]{%d,}[-]{%d,}", nups, ndowns)#
    }#
#
    # generate and apply the peak pattern#
    rc <- gregexpr(peakpat, xc)[[1]]#
    if (rc[1] < 0) return(NULL)
rc
setwd('/Users/HwB/Work/myRforge/optimist/pkg/pracma/R')
    x1 <- rc#
    x2 <- rc + attr(rc, "match.length")#
    attributes(x1) <- NULL#
    attributes(x2) <- NULL
cbind(x1, x2)
setwd('/Users/HwB/Work/myRforge/optimist/pkg/pracma/R')
    n <- length(x1)#
    xv <- xp <- numeric(n)#
    for (i in 1:n) {#
        xp[i] <- which.max(x[x1[i]:x2[i]]) + x1[i] - 1#
        xv[i] <- x[xp[i]]#
    }
cbind(xv, xp, x1, x2)
setwd('/Users/HwB/Work/myRforge/optimist/pkg/pracma/R')
xv - pmax(x[x1], x[x2])
x[x1]
x[x2]
setwd('/Users/HwB/Work/myRforge/optimist/pkg/pracma/R')
which(xv >= minpeakheight & xv - pmax(x[x1], x[x2]) >= threshold)
setwd('/Users/HwB/Work/myRforge/optimist/pkg/pracma/R')
    inds <- which(xv >= minpeakheight & xv - pmax(x[x1], x[x2]) >= threshold)#
#
    # combine into a matrix format#
    X <- cbind(xv[inds], xp[inds], x1[inds], x2[inds])
X
sortstr
sortstr <- TRUE
setwd('/Users/HwB/Work/myRforge/optimist/pkg/pracma/R')
    if (sortstr) {#
        sl <- sort.list(X[, 1], na.last = NA, decreasing = TRUE)#
        X <- X[sl, , drop = FALSE]#
    }
X
findpeaks <- function(x,nups = 1, ndowns = nups, zero = "0", peakpat = NULL, #
                      # peakpat = "[+]{2,}[0]*[-]{2,}", #
                      minpeakheight = -Inf, minpeakdistance = 1,#
                      threshold = 0, npeaks = 0, sortstr = FALSE)#
{#
    stopifnot(is.vector(x, mode="numeric"))#
    if (! zero %in% c('0', '+', '-'))#
        stop("Argument 'zero' can only be '0', '+', or '-'.")#
#
    # transform x into a "+-+...-+-" character string#
    xc <- paste(as.character(sign(diff(x))), collapse="")#
    xc <- gsub("1", "+", gsub("-1", "-", xc))#
    # transform '0' to zero#
    if (zero != '0') xc <- gsub("0", zero, xc)#
#
    # generate the peak pattern with no of ups and downs#
    if (is.null(peakpat)) {#
        peakpat <- sprintf("[+]{%d,}[-]{%d,}", nups, ndowns)#
    }#
#
    # generate and apply the peak pattern#
    rc <- gregexpr(peakpat, xc)[[1]]#
    if (rc[1] < 0) return(NULL)#
#
    # get indices from regular expression parser#
    x1 <- rc#
    x2 <- rc + attr(rc, "match.length")#
    attributes(x1) <- NULL#
    attributes(x2) <- NULL#
#
    # find index positions and maximum values#
    n <- length(x1)#
    xv <- xp <- numeric(n)#
    for (i in 1:n) {#
        xp[i] <- which.max(x[x1[i]:x2[i]]) + x1[i] - 1#
        xv[i] <- x[xp[i]]#
    }#
#
    # eliminate peaks that are too low#
    inds <- which(xv >= minpeakheight & xv - pmax(x[x1], x[x2]) >= threshold)#
#
    # combine into a matrix format#
    X <- cbind(xv[inds], xp[inds], x1[inds], x2[inds])#
#
    # eliminate peaks that are near by#
    if (minpeakdistance != 1)#
        warning("Handling 'minpeakdistance' has not yet been implemented.")#
#
    # Sort according to peak height#
    if (sortstr) {#
        sl <- sort.list(X[, 1], na.last = NA, decreasing = TRUE)#
        X <- X[sl, , drop = FALSE]#
    }#
#
    # Return only the first 'npeaks' peaks#
    if (npeaks > 0 && npeaks < nrow(X)) {#
        X <- X[1:npeaks, , drop = FALSE]#
    }#
#
    if (length(X) == 0)    return(c())#
    # else if (nrow(X) == 1) return(drop(X))#
    else return(X)#
}
x <- c(2, 12, 4, 6, 9, 4, 3, 1, 19, 7)#
identical(findpeaks(x),#
          matrix(c(12,9,19, 2,5,9, 1,3,8, 2,7,9), nrow=3, ncol=4))#
identical(findpeaks(x, npeaks = 1, sortstr = TRUE),#
          matrix(c(19, 9, 8, 9), nrow = 1)#
identical(findpeaks(x, minpeakheight = 15),#
          matrix(c(19, 9, 8, 9), nrow = 1)#
identical(findpeaks(x, threshold = 10),#
          c(19, 9, 8, 9))
identical(findpeaks(x),#
          matrix(c(12,9,19, 2,5,9, 1,3,8, 2,7,9), nrow=3, ncol=4))
findpeaks(x)
identical(findpeaks(x, npeaks = 1, sortstr = TRUE),#
          matrix(c(19, 9, 8, 9), nrow = 1))
findpeaks(x, npeaks = 1, sortstr = TRUE)
matrix(c(19, 9, 8, 9), nrow = 1)
str(findpeaks(x, npeaks = 1, sortstr = TRUE))
str(matrix(c(19, 9, 8, 9), nrow = 1))
identical(findpeaks(x),#
          matrix(c(12,9,19, 2,5,9, 1,3,8, 3,8,10), nrow=3, ncol=4))#
identical(findpeaks(x, npeaks = 1, sortstr = TRUE),#
          matrix(c(19, 9, 8, 10), nrow = 1))#
identical(findpeaks(x, minpeakheight = 15),#
          matrix(c(19, 9, 8, 10), nrow = 1)#
identical(findpeaks(x, threshold = 10),#
          c(19, 9, 8, 10))
identical(findpeaks(x),#
          matrix(c(12,9,19, 2,5,9, 1,3,8, 3,8,10), nrow=3, ncol=4))#
identical(findpeaks(x, npeaks = 1, sortstr = TRUE),#
          matrix(c(19, 9, 8, 10), nrow = 1))#
identical(findpeaks(x, minpeakheight = 15),#
          matrix(c(19, 9, 8, 10), nrow = 1))#
identical(findpeaks(x, threshold = 10),#
          c(19, 9, 8, 10))
findpeaks(x, threshold = 10)
identical(findpeaks(x),#
          matrix(c(12,9,19, 2,5,9, 1,3,8, 3,8,10), nrow=3, ncol=4))#
identical(findpeaks(x, npeaks = 1, sortstr = TRUE),#
          matrix(c(19, 9, 8, 10), nrow = 1))#
identical(findpeaks(x, minpeakheight = 15),#
          matrix(c(19, 9, 8, 10), nrow = 1))#
identical(findpeaks(x, threshold = 10),#
          matrix(c(19, 9, 8, 10), nrow = 1)
)
identical(findpeaks(x),#
          matrix(c(12,9,19, 2,5,9, 1,3,8, 3,8,10), nrow=3, ncol=4))#
identical(findpeaks(x, npeaks = 1, sortstr = TRUE),#
          matrix(c(19, 9, 8, 10), nrow = 1))#
identical(findpeaks(x, minpeakheight = 15),#
          matrix(c(19, 9, 8, 10), nrow = 1))#
identical(findpeaks(x, threshold = 10),#
          matrix(c(19, 9, 8, 10), nrow = 1))
